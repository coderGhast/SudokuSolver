<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_25) on Fri Oct 25 01:50:46 BST 2013 -->
<title>SolverModel</title>
<meta name="date" content="2013-10-25">
<link rel="stylesheet" type="text/css" href="../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="SolverModel";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../assignment1/package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/SolverModel.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-files/index-1.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../assignment1/SolverFrame.html" title="class in assignment1"><span class="strong">Prev Class</span></a></li>
<li><a href="../assignment1/SudFileFilter.html" title="class in assignment1"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../index.html?assignment1/SolverModel.html" target="_top">Frames</a></li>
<li><a href="SolverModel.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">assignment1</div>
<h2 title="Class SolverModel" class="title">Class SolverModel</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>assignment1.SolverModel</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="strong">SolverModel</span>
extends java.lang.Object</pre>
<div class="block"><h2>SolverModel</h2>
 <p>
 Deals with all operations upon the values and candidates of the Cells, in
 respect to their location and status within the 'Sudoku' grid. <br />
 Many different algorithms are used in order to solve a variety of different
 sudoku puzzles, some easy and some a little tougher. This is the 'heart' of
 the SudokuSolver.
 </p>
 <p>
 Many algorithms are self contained, and attempt to use the same code for both
 Rows and Columns. Some methods grew larger and needed to be split into
 multiple methods (i.e. PointingPairs - Large If statement conditions), for
 ease of maintainability and explanation.
 </p>
 <p>
 Collection tends to refer to a Row, Column or Block. <br />
 Each method returns a 'Result', containing it's success, any cells affected
 and any message attached to the success. More can be seen on this in the
 JavaDoc for 'Result.class'.
 </p></div>
<dl><dt><span class="strong">Version:</span></dt>
  <dd>1.0</dd>
<dt><span class="strong">Author:</span></dt>
  <dd>James Euesden - jee22@aber.ac.uk</dd></dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../assignment1/SolverModel.html#SolverModel()">SolverModel</a></strong>()</code>
<div class="block">
 Constructor prepares class for use by making new instances of
 'allCollections', which holds all rows, columns and blocks as ordered
 lists.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../assignment1/SolverModel.html#appendCellInfo(assignment1.Cell)">appendCellInfo</a></strong>(<a href="../assignment1/Cell.html" title="class in assignment1">Cell</a>&nbsp;cell)</code>
<div class="block">
 Appends common information to a StringBuffer to be set and returned in
 the result.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../assignment1/SolverModel.html#defineBlocks()">defineBlocks</a></strong>()</code>
<div class="block">
 Similar to defineRowsAndColumns, yet involving slightly different use of
 nested for loops, as each block starts, continues for 3 cells, then moves
 down a row (or across a column, depending how you build it.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../assignment1/SolverModel.html#defineRowsAndColumns()">defineRowsAndColumns</a></strong>()</code>
<div class="block">
 Through the use of a nested for loop, gets what would be each Cell in a
 'Row' or 'Column' (depdning on 'direction' of i and j) and adds them into
 the overall list of collections (Row, Column, Block).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.LinkedList&lt;java.util.LinkedList&lt;<a href="../assignment1/Cell.html" title="class in assignment1">Cell</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="../assignment1/SolverModel.html#getAllCollections()">getAllCollections</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../assignment1/Cell.html" title="class in assignment1">Cell</a>[][]</code></td>
<td class="colLast"><code><strong><a href="../assignment1/SolverModel.html#getGrid()">getGrid</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../assignment1/Result.html" title="class in assignment1">Result</a></code></td>
<td class="colLast"><code><strong><a href="../assignment1/SolverModel.html#hiddenSingles()">hiddenSingles</a></strong>()</code>
<div class="block">
 Hidden Singles in Sudoku looks for any cells that have only one candidate
 left in their candidates list.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../assignment1/Result.html" title="class in assignment1">Result</a></code></td>
<td class="colLast"><code><strong><a href="../assignment1/SolverModel.html#nakedPairsAndTriples()">nakedPairsAndTriples</a></strong>()</code>
<div class="block">
 The technique of nakedPairsAndTriples relies upon finding Cells who have
 only two or three values, shared between one another, within a
 collection.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../assignment1/SolverModel.html#nakedPairsAndTriplesRemoveCandidates(java.util.LinkedList, java.util.LinkedList, java.util.LinkedList)">nakedPairsAndTriplesRemoveCandidates</a></strong>(java.util.LinkedList&lt;<a href="../assignment1/Cell.html" title="class in assignment1">Cell</a>&gt;&nbsp;currentCollection,
                                    java.util.LinkedList&lt;java.lang.Integer&gt;&nbsp;toRemove,
                                    java.util.LinkedList&lt;<a href="../assignment1/Cell.html" title="class in assignment1">Cell</a>&gt;&nbsp;doNotTouch)</code>
<div class="block">
 Part of the nakedPairsAndTriples algorithm, we first go through each
 candidate for potential removal and with this look at each cell in the
 collection.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../assignment1/Result.html" title="class in assignment1">Result</a></code></td>
<td class="colLast"><code><strong><a href="../assignment1/SolverModel.html#nakedSingles()">nakedSingles</a></strong>()</code>
<div class="block">
 Standard Sudoku technique involving looking through each Cell in the grid
 in a particular collection and finding those with a value that appears
 within that Cell and only that Cell in that one particular collection,
 even if it belongs to another collection that has many cells looking for
 this candidate.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../assignment1/Result.html" title="class in assignment1">Result</a></code></td>
<td class="colLast"><code><strong><a href="../assignment1/SolverModel.html#pointingPairs(int)">pointingPairs</a></strong>(int&nbsp;mod)</code>
<div class="block">
 Checks for pairs within a row or column that 'point'
 towards other Cells that hold candidates to be removed,
 as the pair itself hold the candidates to be removed.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../assignment1/SolverModel.html#pointingPairsPairUp(java.util.LinkedList, int, int, int, boolean)">pointingPairsPairUp</a></strong>(java.util.LinkedList&lt;<a href="../assignment1/Cell.html" title="class in assignment1">Cell</a>&gt;&nbsp;currentBlock,
                   int&nbsp;modifier,
                   int&nbsp;candidate,
                   int&nbsp;i,
                   boolean&nbsp;useFirst)</code>
<div class="block">
 Part of pointingPairs - removed to break up the code
 and make it easier to read and maintain.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../assignment1/SolverModel.html#pointingPairsStripCandidates(int, assignment1.Cell, int)">pointingPairsStripCandidates</a></strong>(int&nbsp;modifier,
                            <a href="../assignment1/Cell.html" title="class in assignment1">Cell</a>&nbsp;firstCell,
                            int&nbsp;candidate)</code>
<div class="block">
 In order to split larger chunks of
 code up from pointingPairs() and make
 it more maintainable, there is this method
 that strips the candidates from the other
 Cells in the Row/Column should the previous
 tests and validations have passed.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../assignment1/SolverModel.html#pointingPairsValidateCell(assignment1.Cell, assignment1.Cell, int)">pointingPairsValidateCell</a></strong>(<a href="../assignment1/Cell.html" title="class in assignment1">Cell</a>&nbsp;firstCell,
                         <a href="../assignment1/Cell.html" title="class in assignment1">Cell</a>&nbsp;cellCheck,
                         int&nbsp;modifier)</code>
<div class="block">
 Checks that the Cell being passed does not belong
 on the same Row or Column as the Pair, ensuring that
 candidates are not removed from the pair or that
 candidates are valid (i.e.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../assignment1/SolverModel.html#printLines()">printLines</a></strong>()</code>
<div class="block">
 My original way of viewing the steps and results taken as the Sudoku
 puzzle solves.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../assignment1/Result.html" title="class in assignment1">Result</a></code></td>
<td class="colLast"><code><strong><a href="../assignment1/SolverModel.html#removeCollectionCandidates()">removeCollectionCandidates</a></strong>()</code>
<div class="block">
 Removes candidates from each Cell based on what candidates currently
 exist in the grid.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../assignment1/SolverModel.html#setCells(int[][])">setCells</a></strong>(int[][]&nbsp;lines)</code>
<div class="block">
 What values, including 0, to set to particular Cells to build the current
 Sudoku puzzle.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../assignment1/SolverModel.html#solved()">solved</a></strong>()</code>
<div class="block">
 Checks all Cells in the puzzle.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="SolverModel()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>SolverModel</h4>
<pre>public&nbsp;SolverModel()</pre>
<div class="block"><p>
 Constructor prepares class for use by making new instances of
 'allCollections', which holds all rows, columns and blocks as ordered
 lists.
 </p></div>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="setCells(int[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setCells</h4>
<pre>public&nbsp;void&nbsp;setCells(int[][]&nbsp;lines)</pre>
<div class="block"><p>
 What values, including 0, to set to particular Cells to build the current
 Sudoku puzzle.
 </p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>lines</code> - - Cells as read in by FileHandler.</dd></dl>
</li>
</ul>
<a name="defineRowsAndColumns()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defineRowsAndColumns</h4>
<pre>public&nbsp;void&nbsp;defineRowsAndColumns()</pre>
<div class="block"><p>
 Through the use of a nested for loop, gets what would be each Cell in a
 'Row' or 'Column' (depdning on 'direction' of i and j) and adds them into
 the overall list of collections (Row, Column, Block).
 </p></div>
</li>
</ul>
<a name="defineBlocks()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defineBlocks</h4>
<pre>public&nbsp;void&nbsp;defineBlocks()</pre>
<div class="block"><p>
 Similar to defineRowsAndColumns, yet involving slightly different use of
 nested for loops, as each block starts, continues for 3 cells, then moves
 down a row (or across a column, depending how you build it. This example
 starts and iterates over rows).
 </p>
 <p>
 By using multiple nested for loops, and knowing that each block is size
 of 3, we can increment through the Cells relatively easy. <br />
 For example, we know that Block 2 (last on top Row), starts at, and
 includes, cell (0, 6), which would be reached by rowStart = n *
 Block_Spaces, or, 2 * Block_Spaces = 6. From there, it's a simple case of
 iterating through the grid to grab the rows in each block below the
 starting block when we know where to start and that no block goes more
 than +3 in either rows or columns from the start.
 </p></div>
</li>
</ul>
<a name="getAllCollections()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAllCollections</h4>
<pre>public&nbsp;java.util.LinkedList&lt;java.util.LinkedList&lt;<a href="../assignment1/Cell.html" title="class in assignment1">Cell</a>&gt;&gt;&nbsp;getAllCollections()</pre>
<dl><dt><span class="strong">Returns:</span></dt><dd>The full list of Row, Column and Blocks.</dd></dl>
</li>
</ul>
<a name="removeCollectionCandidates()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeCollectionCandidates</h4>
<pre>public&nbsp;<a href="../assignment1/Result.html" title="class in assignment1">Result</a>&nbsp;removeCollectionCandidates()</pre>
<div class="block"><p>
 Removes candidates from each Cell based on what candidates currently
 exist in the grid. <br />
 Searches the grid and adds existing values to a list, then goes through
 this list and removes any cells that hold them as candidates in each type
 of collection.
 </p></div>
<dl><dt><span class="strong">Returns:</span></dt><dd>Result of operation.</dd></dl>
</li>
</ul>
<a name="nakedSingles()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nakedSingles</h4>
<pre>public&nbsp;<a href="../assignment1/Result.html" title="class in assignment1">Result</a>&nbsp;nakedSingles()</pre>
<div class="block"><p>
 Standard Sudoku technique involving looking through each Cell in the grid
 in a particular collection and finding those with a value that appears
 within that Cell and only that Cell in that one particular collection,
 even if it belongs to another collection that has many cells looking for
 this candidate. <br />
 Due to only one cell available for this candidate, it is only possible
 for this cell to be this value, and so it is set to the cell.
 </p></div>
<dl><dt><span class="strong">Returns:</span></dt><dd>Result of operation.</dd></dl>
</li>
</ul>
<a name="nakedPairsAndTriples()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nakedPairsAndTriples</h4>
<pre>public&nbsp;<a href="../assignment1/Result.html" title="class in assignment1">Result</a>&nbsp;nakedPairsAndTriples()</pre>
<div class="block"><p>
 The technique of nakedPairsAndTriples relies upon finding Cells who have
 only two or three values, shared between one another, within a
 collection. <br />
 We can be assured that if we find two cells in the collection who share
 the two same candidates, then the values must belong to these cells and
 no others, so those candidates are removed from other cells in the
 collection. <br />
 In the case of finding three cells with three values, the same applies.
 However, the same is also true if we find a cell that may have three
 candidates, shared between two cells with only two candidates (e.g. {3,
 6, 9}, {6,9}, {3,9}). Even with this in case, we know that out of all
 cells, only these three can really contain these values, as other cells
 have other options. Once again, this leads to removing, this time three,
 candidates from the other cells in the collection. <br />
 The other possibility is that three cells appear with three candidates
 split between them, but no one cell has three candidates to itself. My
 algorithm here is not strong enough handle these situations. (e.g. {3,4},
 {3,9}, {4,9} in the same collection).
 </p></div>
<dl><dt><span class="strong">Returns:</span></dt><dd>Result of operation</dd></dl>
</li>
</ul>
<a name="nakedPairsAndTriplesRemoveCandidates(java.util.LinkedList, java.util.LinkedList, java.util.LinkedList)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nakedPairsAndTriplesRemoveCandidates</h4>
<pre>public&nbsp;boolean&nbsp;nakedPairsAndTriplesRemoveCandidates(java.util.LinkedList&lt;<a href="../assignment1/Cell.html" title="class in assignment1">Cell</a>&gt;&nbsp;currentCollection,
                                           java.util.LinkedList&lt;java.lang.Integer&gt;&nbsp;toRemove,
                                           java.util.LinkedList&lt;<a href="../assignment1/Cell.html" title="class in assignment1">Cell</a>&gt;&nbsp;doNotTouch)</pre>
<div class="block"><p>
 Part of the nakedPairsAndTriples algorithm, we first go through each
 candidate for potential removal and with this look at each cell in the
 collection. <br />
 For each cell, if it is unsolved, is not one of the Cells not to be
 altered and that the amount of candidates to remove is equal to the
 amount of cells not to be altered, remove the candidate from the cell.
 </p>
 <p>
 The check of size of the list of Cells not to be altered versus the
 amount of candidates to be removed is very important. It is this check
 that ensures if we are removing anything, it is no more and no less than
 we have pairs. If it were otherwise, it would mean that the values do not
 work as pairs/triples.
 </p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>currentCollection</code> - - Current Row/Column/Block</dd><dd><code>toRemove</code> - - candidates for potential removal</dd><dd><code>doNotTouch</code> - - Cells not to be altered</dd>
<dt><span class="strong">Returns:</span></dt><dd>Result of operation.</dd></dl>
</li>
</ul>
<a name="pointingPairs(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pointingPairs</h4>
<pre>public&nbsp;<a href="../assignment1/Result.html" title="class in assignment1">Result</a>&nbsp;pointingPairs(int&nbsp;mod)</pre>
<div class="block"><p>
 Checks for pairs within a row or column that 'point'
 towards other Cells that hold candidates to be removed,
 as the pair itself hold the candidates to be removed.
 </p>
 <p>
 A 'pair' is looked for along the row or a column or 
 each individual Block. If they are found to have matching
 candidates, and only those have the candidate in the 
 individual block, we know we can remove the candidates
 from all other cells in the row/column, that the cells
 appear in, outside of the box. They are 'pointing' at
 cells that need candidates removed, hence the name.
 </p>
 <p>
 The 'mod' parameter is a modifier that should either be
 a 1 (rows) or 3 (columns). Using simple arithmetic, and
 knowing that the size of a sudoku grid is always 9x9, a
 block is always 3x3 and there is also a static amount of
 Cells, columns, rows and blocks, the behaviour of the
 method can be altered using this modifier.
 </p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>mod</code> - - A modifier, either 1 or 3, representing rows
 or columns, respectively.</dd>
<dt><span class="strong">Returns:</span></dt><dd>The result of the operation</dd></dl>
</li>
</ul>
<a name="pointingPairsPairUp(java.util.LinkedList, int, int, int, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pointingPairsPairUp</h4>
<pre>public&nbsp;boolean&nbsp;pointingPairsPairUp(java.util.LinkedList&lt;<a href="../assignment1/Cell.html" title="class in assignment1">Cell</a>&gt;&nbsp;currentBlock,
                          int&nbsp;modifier,
                          int&nbsp;candidate,
                          int&nbsp;i,
                          boolean&nbsp;useFirst)</pre>
<div class="block"><p>
 Part of pointingPairs - removed to break up the code
 and make it easier to read and maintain.
 <br />
 Checks if the two Cell to potentially be paired up
 in the Row/Column both don't have a value and share the
 candidate expected.
 <br />
 Use first refers to whether the first Cell in the Row/Column
 was selected, or if the second one was. The if statement
 handles both of these outcomes with an OR statement, so
 that if either of these is true, then it may indeed be
 a pair.
 </p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>currentBlock</code> - - The block to be checked</dd><dd><code>modifier</code> - - rows/columns modifier</dd><dd><code>candidate</code> - - What candidate to be expected and compared</dd><dd><code>i</code> - - the location of the Cells being compared in the grid, when used
 with the modifier</dd><dd><code>useFirst</code> - - whether the first or second Cell is the paired Cell
 to be checked, based on which was available.</dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="pointingPairsValidateCell(assignment1.Cell, assignment1.Cell, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pointingPairsValidateCell</h4>
<pre>public&nbsp;boolean&nbsp;pointingPairsValidateCell(<a href="../assignment1/Cell.html" title="class in assignment1">Cell</a>&nbsp;firstCell,
                                <a href="../assignment1/Cell.html" title="class in assignment1">Cell</a>&nbsp;cellCheck,
                                int&nbsp;modifier)</pre>
<div class="block"><p>
 Checks that the Cell being passed does not belong
 on the same Row or Column as the Pair, ensuring that
 candidates are not removed from the pair or that
 candidates are valid (i.e. contained only in that
 one row/column and not any others in the block).
 </p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>firstCell</code> - - First cell for pairing check</dd><dd><code>cellCheck</code> - - Cell to validate whether the
 candidate is in the single Row/Column or elsewhere
 in the block.</dd><dd><code>modifier</code> - - Rows/Columns modifier</dd>
<dt><span class="strong">Returns:</span></dt><dd>- Whether the validation was true or false.</dd></dl>
</li>
</ul>
<a name="pointingPairsStripCandidates(int, assignment1.Cell, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pointingPairsStripCandidates</h4>
<pre>public&nbsp;boolean&nbsp;pointingPairsStripCandidates(int&nbsp;modifier,
                                   <a href="../assignment1/Cell.html" title="class in assignment1">Cell</a>&nbsp;firstCell,
                                   int&nbsp;candidate)</pre>
<div class="block"><p>
 In order to split larger chunks of
 code up from pointingPairs() and make
 it more maintainable, there is this method
 that strips the candidates from the other
 Cells in the Row/Column should the previous
 tests and validations have passed.
 </p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>modifier</code> - </dd><dd><code>firstCell</code> - </dd><dd><code>candidate</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="hiddenSingles()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hiddenSingles</h4>
<pre>public&nbsp;<a href="../assignment1/Result.html" title="class in assignment1">Result</a>&nbsp;hiddenSingles()</pre>
<div class="block"><p>
 Hidden Singles in Sudoku looks for any cells that have only one candidate
 left in their candidates list. If they only have one candidate option, it
 means they must be this candidate without a doubt (presuming correct
 solutions to this point).
 </p></div>
<dl><dt><span class="strong">Returns:</span></dt><dd>- Result of the operation.</dd></dl>
</li>
</ul>
<a name="solved()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solved</h4>
<pre>public&nbsp;boolean&nbsp;solved()</pre>
<div class="block"><p>
 Checks all Cells in the puzzle. If each one of them has a value (based on
 a counter increasing on each positive value found, then the method
 returns true. <br />
 MAX_CELLS = 81, the full Sudoku grid cells.
 </p></div>
<dl><dt><span class="strong">Returns:</span></dt><dd>boolean referring to is the puzzle has been solved or not.</dd></dl>
</li>
</ul>
<a name="getGrid()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getGrid</h4>
<pre>public&nbsp;<a href="../assignment1/Cell.html" title="class in assignment1">Cell</a>[][]&nbsp;getGrid()</pre>
<dl><dt><span class="strong">Returns:</span></dt><dd>the current full grid of Cells.</dd></dl>
</li>
</ul>
<a name="appendCellInfo(assignment1.Cell)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>appendCellInfo</h4>
<pre>public&nbsp;java.lang.String&nbsp;appendCellInfo(<a href="../assignment1/Cell.html" title="class in assignment1">Cell</a>&nbsp;cell)</pre>
<div class="block"><p>
 Appends common information to a StringBuffer to be set and returned in
 the result. In particular, information concerning cells and their
 location.
 </p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>cell</code> - - current cell modified</dd>
<dt><span class="strong">Returns:</span></dt><dd>the completed and concatanated String</dd></dl>
</li>
</ul>
<a name="printLines()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>printLines</h4>
<pre>public&nbsp;void&nbsp;printLines()</pre>
<div class="block"><p>
 My original way of viewing the steps and results taken as the Sudoku
 puzzle solves. Left in for sake of re-usability should the GUI need to be
 removed. <br />
 Prints out the current status of the board, with dividers for the Blocks
 and underscores for unsolved cells. Does not display candidates.
 </p></div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../assignment1/package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/SolverModel.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-files/index-1.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../assignment1/SolverFrame.html" title="class in assignment1"><span class="strong">Prev Class</span></a></li>
<li><a href="../assignment1/SudFileFilter.html" title="class in assignment1"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../index.html?assignment1/SolverModel.html" target="_top">Frames</a></li>
<li><a href="SolverModel.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
